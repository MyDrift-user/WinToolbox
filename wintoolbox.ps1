################################################################################################################
###                                                                                                          ###
### WARNING: This file is automatically generated DO NOT modify this file directly as it will be overwritten ###
###                                                                                                          ###
################################################################################################################

<#
.NOTES
    Author         : MyDrift @mydrift-user
    GitHub         : https://github.com/mydrift-user
    ?              : pnp powershell instead of Get-Credential?
    TODO           : create session without prequisits on remote machine
    TODO           : delete logs older than 30 days | create config for that (checkbox in settings tab (rename sources to settings) rename sources as subtab)
    TODO           : package as .exe (github & website)
    TODO           : save an additional script and put it in task scheduler. after 30 days of not running the script it deleats the logs, the task and itself.
    TODO           : Run on system boot -> task scheduler checks for windows version change and then runs the selected/needed tweaks.
#>



# check if codes are running in an elevated session. if not, restart the script in an elevated session
if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
    # If not elevated, relaunch the script in a new elevated PowerShell session
    #TODO save script in directory, change escapedcommand to run that saved script instead of rerequest code.
    $escapedCommand = 'irm mdiana.win | iex'
    Start-Process PowerShell -ArgumentList "-Command", $escapedCommand -Verb RunAs
    exit
}


Write-Host "

MMMMMMMM               MMMMMMMM    DDDDDDDDDDDDDD        
M:::::::M             M:::::::M    D:::::::::::::DDD     
M::::::::M           M::::::::M    D::::::::::::::::DD   
M:::::::::M         M:::::::::M    DDD:::::DDDDD::::::D  
M::::::::::M       M::::::::::M       D:::::D   D::::::D 
M:::::::::::M     M:::::::::::M       D:::::D    D::::::D
M:::::::M::::M   M::::M:::::::M       D:::::D     D::::::D
M::::::M M::::M M::::M M::::::M       D:::::D     D::::::D
M::::::M  M::::M::::M  M::::::M       D:::::D     D::::::D
M::::::M   M:::::::M   M::::::M       D:::::D     D::::::D
M::::::M    M:::::M    M::::::M       D:::::D    D::::::D
M::::::M     MMMMM     M::::::M       D:::::D   D::::::D 
M::::::M               M::::::M    DDD:::::DDDDD::::::D  
M::::::M               M::::::M    D::::::::::::::::DD   
M::::::M               M::::::M    D:::::::::::::DDD     
MMMMMMMM               MMMMMMMM    DDDDDDDDDDDDDD        


========Mattia Diana========

=====Powershell Toolbox=====
=======Managing Device======


"

$dateTime = Get-Date -Format "dd-MM-yyyy_HH-mm-ss"
Start-Transcript -Path "C:\Windows\WinToolBox\Logs\WinToolBox_$dateTime.log" -Append
#Get-Content "C:\Windows\WinToolbox\Logs\manager_$dateTime.log"

function Get-JsonConfig {
    param (
        [string]$ConfigPath = "C:\Windows\WinToolBox\config.json"
    )

    if (Test-Path -Path $ConfigPath) {
        $json = Get-Content -Path $ConfigPath -Raw | ConvertFrom-Json
        return $json
    } else {
        return $null
    }
}

function Set-JsonConfig {
    param (
        [Parameter(Mandatory)]
        [PSCustomObject]$JsonData,

        [string]$ConfigPath = "C:\Windows\WinToolBox\config.json"
    )

    $JsonData | ConvertTo-Json -Depth 5 | Set-Content -Path $ConfigPath
}


# Load WPF and XAML libraries
Add-Type -AssemblyName PresentationCore, WindowsBase, PresentationFramework, System.Drawing, WindowsFormsIntegration

# WPF GUI Design in XAML
[xml]$xaml = @"
<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="WinToolbox" Height="450" Width="800">
    <Window.Resources>
        <Style x:Key="ToggleSwitchStyle" TargetType="{x:Type ToggleButton}">
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="{x:Type ToggleButton}">
                        <Border x:Name="border" Width="50" Height="25" CornerRadius="12.5" BorderBrush="#00FFFFFF" BorderThickness="1"> <!-- or gray -->
                            <Grid x:Name="grid">
                                <!-- Toggle button (circle) is always white -->
                                <Ellipse Fill="White" Width="20" Height="20" Margin="1" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"/>
                            </Grid>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsChecked" Value="True">
                                <!-- Background changes to green when toggled on -->
                                <Setter TargetName="border" Property="Background" Value="#33a442" />
                                <Setter TargetName="grid" Property="HorizontalAlignment" Value="Right" />
                            </Trigger>
                            <Trigger Property="IsChecked" Value="False">
                                <!-- Background changes to red when toggled off -->
                                <Setter TargetName="border" Property="Background" Value="Red" />
                                <Setter TargetName="grid" Property="HorizontalAlignment" Value="Left" />
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </Window.Resources>
    

    <DockPanel LastChildFill="True">
        <Expander Name="DeviceMGMTexpander" ExpandDirection="Right" IsExpanded="False">
            <Grid Grid.Column="0">
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto" /> <!-- For static controls: TextBox and Buttons -->
                    <RowDefinition Height="*" /> <!-- For ScrollViewer, will take up remaining space -->
                </Grid.RowDefinitions>

                <StackPanel Grid.Row="0" Margin="10">
                    <TextBox Name="txtHostname" />
                    <Button Name="btnAdd" Content="Add" />
                    <Button Name="btnRemove" Content="Remove Selection" />
                </StackPanel>

                <!-- ScrollViewer in a separate row, taking up the remaining space -->
                <ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Hidden">
                    <StackPanel Name="panelDevices" />
                </ScrollViewer>
            </Grid>
        </Expander>
        
        <TabControl Grid.Column="1" Margin="10">
            <TabItem Header="Windows">
                <!-- Nested TabControl for the three new tabs -->
                <TabControl x:Name="subTabControl">
                    <TabItem Header="Applications" x:Name="tabApplications">
                        <Grid> <!-- Ein Grid als Container f端r die gesamte Struktur -->
                            <Grid.RowDefinitions>
                                <RowDefinition Height="Auto"/> <!-- Reihe f端r die Buttons -->
                                <RowDefinition Height="*"/> <!-- Reihe f端r den ScrollViewer -->
                            </Grid.RowDefinitions>
                            <!-- Buttons oben im Grid -->
                            <StackPanel Grid.Row="0" Orientation="Horizontal" HorizontalAlignment="Left" Margin="10">
                                <Button Name="btnInstallSelection" Content="Install/Upgrade Selection" Margin="5"/>
                                <Button Name="btnUpdateAll" Content="Update All" Margin="5"/>
                                <Button Name="btnUninstallSelection" Content="Uninstall Selection" Margin="5"/>
                                <Button Name="btnShowInstalled" Content="Show Installed" Margin="5"/>
                                <Button Name="btnClearSelection" Content="Clear Selection" Margin="5"/>
                            </StackPanel>
                            <!-- ScrollViewer f端r die Applikationsliste in der zweiten Reihe des Grids -->
                            <ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Auto">
                                <WrapPanel Name="appspanel" Orientation="Horizontal">
                                        <!-- Dynamically added CheckBoxes will be placed here -->
                                </WrapPanel>
                            </ScrollViewer>
                        </Grid>
                    </TabItem>
                    <TabItem Header="Tweaks">
                        <Grid>
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="*" />
                                <ColumnDefinition Width="*" />
                            </Grid.ColumnDefinitions>
                            <!-- First Column for checkboxes and buttons -->
                            <Grid Grid.Column="0">
                                <Grid.RowDefinitions>
                                    <RowDefinition Height="*" />
                                    <RowDefinition Height="Auto" />
                                </Grid.RowDefinitions>
                                <!-- Checkboxes StackPanel -->
                                <StackPanel Name="tweaksPanel" Margin="10">
                                    <!-- Checkboxes will be added here in the script -->
                                </StackPanel>
                                <!-- Buttons at the bottom -->
                                <StackPanel Grid.Row="1" Orientation="Horizontal" HorizontalAlignment="Center" Margin="10">
                                    <Button Name="btnRunTweaks" Content="Run Selected" Margin="5" Width="100" />
                                    <Button Name="btnUndoTweaks" Content="Undo Selected" Margin="5" Width="100" />
                                </StackPanel>
                            </Grid>
                            <!-- Second Column for toggle switch and other controls -->
                            <StackPanel Grid.Column="1" Margin="10">
                                <ToggleButton Name="btnToggleDarkMode" Style="{StaticResource ToggleSwitchStyle}" Margin="10" IsChecked="False" HorizontalAlignment="Left"/>
                                <TextBlock Name="txtToggleTheme" VerticalAlignment="Center" Text="Dark Mode" HorizontalAlignment="Left"/>
                                <ToggleButton Name="btnToggleBingSearch" Style="{StaticResource ToggleSwitchStyle}" Margin="10" IsChecked="False" HorizontalAlignment="Left"/>
                                <TextBlock Name="txtToggleBingSearchStatus" VerticalAlignment="Center" Text="Bing Search in Start Menu" HorizontalAlignment="Left"/>
                                <Button Name="btnCreateShortcut" Content="Create Shortcut" Margin="5" HorizontalAlignment="Left"/>
                            </StackPanel>
                        </Grid>
                    </TabItem>
                </TabControl>
            </TabItem>
            <TabItem Header="Sources">
                <StackPanel Margin="10">
                    <DockPanel LastChildFill="False">
                        <TextBox Name="txtNewSource" DockPanel.Dock="Left" Width="200" Margin="0,0,5,10"/>
                        <ComboBox Name="cmbSourceType" Width="120" Margin="0,0,5,10">
                            <ComboBoxItem Content="Application"/>
                            <ComboBoxItem Content="Tweak"/>
                        </ComboBox>
                        <Button Name="btnAddSource" Content="Add" Width="75" Margin="5,0,0,10"/>
                    </DockPanel>
                    <TextBlock Margin="0,20,0,0" FontWeight="Bold">Current Sources:</TextBlock>
                    <ScrollViewer VerticalScrollBarVisibility="Visible">
                        <StackPanel Name="panelSources" />
                    </ScrollViewer>
                    <Button Name="btnDeleteSource" Content="Delete Source" Margin="10"/>
                </StackPanel>
            </TabItem>
        </TabControl>
    </DockPanel>
</Window>
"@

# Parse the XAML
$reader = New-Object System.Xml.XmlNodeReader $xaml
$window = [Windows.Markup.XamlReader]::Load($reader)

$subTabControl = $window.FindName("subTabControl")

# Check for Internet connection before showing the window
$tabApplications = $window.FindName("tabApplications")  # Get the Applications tab reference

$network = $null

if (-not (Test-Connection 8.8.8.8 -Quiet -Count 1)) {
    $tabApplications.Visibility = [System.Windows.Visibility]::Collapsed
    $subTabControl.SelectedIndex = 1
    Write-Host "No Internet Connection: Hiding Applications Tab"
    $network = "false"
} else {
    $tabApplications.Visibility = [System.Windows.Visibility]::Visible
    $subTabControl.SelectedIndex = 0
    #Write-Host "Internet Connection Detected: Displaying Applications Tab"
    $network = "true"
}


# URL to the ICO file
$iconUrl = "https://raw.githubusercontent.com/MyDrift-user/WinToolbox/main/logo.ico"
$iconPath = "C:\Windows\WinToolbox\assets\logo.ico"

# Ensure the directory exists
$directoryPath = [System.IO.Path]::GetDirectoryName($iconPath)
if (-not (Test-Path -Path $directoryPath)) {
    Write-Host "Creating directory: $directoryPath"
    New-Item -Path $directoryPath -ItemType Directory -Force
}

# Download the ICO file
if ($network -eq "true") {
    try {
        Invoke-WebRequest -Uri $iconUrl -OutFile $iconPath

        # Create an ImageSource from the ICO file
        $iconUri = New-Object System.Uri($iconPath)
        $iconBitmap = New-Object System.Windows.Media.Imaging.BitmapImage($iconUri)

        # Set the Window Icon
        $window.Icon = $iconBitmap

    } catch {
        Write-Host "Failed to download & load the ICO file. Error: $($_.Exception.Message)"
    }
}

# Access controls from the parsed XAML
$txtHostname = $window.FindName("txtHostname")
$btnAdd = $window.FindName("btnAdd")
$btnRemove = $window.FindName("btnRemove")
$panelDevices = $window.FindName("panelDevices")
$btnRun = $window.FindName("btnRun")

$txtNewSource = $window.FindName("txtNewSource")
$cmbSourceType = $window.FindName("cmbSourceType")
$btnAddSource = $window.FindName("btnAddSource")
$lstSources = $window.FindName("lstSources")
$panelSources = $window.FindName("panelSources")
$btnDeleteSource = $window.FindName("btnDeleteSource")
$btnAddSource.Add_Click({ Add-Source })
$btnDeleteSource.Add_Click({ Remove-Source })
$btnAdd.Add_Click({ Add-Device })
$btnRemove.Add_Click({ Remove-Device })


$btnInstallSelection = $window.FindName("btnInstallSelection")
$btnInstallSelection.Add_Click({ Install-SelectedApps })
$btnUninstallSelection = $window.FindName("btnUninstallSelection")
$btnUpdateAll = $window.FindName("btnUpdateAll")
$btnUpdateAll.Add_Click({ Update-AllApps })
$btnShowInstalled = $window.FindName("btnShowInstalled")
$btnUninstallSelection.Add_Click({ Uninstall-Selection })
$btnShowInstalled.Add_Click({ Show-Installed })

# Shortcut Creation
$btnCreateShortcut = $window.FindName("btnCreateShortcut")
$btnCreateShortcut.Add_Click({ Create-Shortcut })

# Correct XML manipulation
$appspanel = $window.FindName("appspanel")

$config = Get-JsonConfig
$DeviceMGMTexpander = $window.FindName("DeviceMGMTexpander")
if ($config -and $config.DeviceMGMTexpander -and $config.DeviceMGMTexpander.expanded -eq "True") {
    $DeviceMGMTexpander.IsExpanded = $true
} else {
    $DeviceMGMTexpander.IsExpanded = $false
}


# Handler for clearing all application checkboxes
$btnClearSelection = $window.FindName("btnClearSelection")
$btnClearSelection.Add_Click({ Clear-Selection })

function Clear-Selection {
    # Iterate through all checkboxes in the applications panel
    foreach ($expander in $appspanel.Children) {
        $stackPanel = $expander.Content
        foreach ($checkBox in $stackPanel.Children) {
            $checkBox.IsChecked = $false
        }
    }
}

function Install-PackageManagers {
    if ($network -eq "true") {
        # Check if Chocolatey is installed
        if (Get-Command choco -ErrorAction SilentlyContinue) {
            $currentVersion = choco --version | Out-String
            #Write-Host "Current Chocolatey version: $currentVersion"
            try {
                #Write-Host "Checking for updates for Chocolatey..."
                $output = choco upgrade chocolatey -y | Out-String  # Capture the full output as a string
                if ($output -like "*is the latest version available based on your source(s)*") {
                    Write-Host ""
                    Write-Host "Chocolatey is installed. Version: $currentVersion"
                } elseif ($output -like "*Chocolatey upgraded 0/1 packages*") {
                    Write-Host "No updates were needed; Chocolatey is already at the latest version. Version: $currentVersion"
                } elseif ($output -like "*Chocolatey upgraded 1/1 packages*" -or $output -like "*upgraded*") {
                    $newVersion = choco --version | Out-String
                    Write-Host "Chocolatey has been updated to the latest version: $newVersion"
                } else {
                    Write-Host "Chocolatey update status is unclear. Check the output above for more details."
                }
            } catch {
                Write-Host "An error occurred while trying to update Chocolatey: $($_.Exception.Message)"
            }
        } else {
            Write-Host "Chocolatey is not installed. Installing now."
            try {
                # Installing Chocolatey
                Set-ExecutionPolicy Bypass -Scope Process -Force
                [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
                iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
                $installedVersion = choco --version | Out-String
                Write-Host "Chocolatey installed successfully. Version: $installedVersion"
            } catch {
                Write-Host "Failed to install Chocolatey: $($_.Exception.Message)"
            }
        }

        # Check and install/update winget
        try {
            $wingetInstalled = winget --version
            if ($wingetInstalled) {
                Write-Host "winget is installed. Version: $wingetInstalled"
            } else {
                throw "winget not installed"
            }
        } catch {
            Write-Host "Attempting to install/update winget..."
            try {
                if (Get-Command choco -ErrorAction SilentlyContinue) {
                    try {
                        choco install winget -y
                        Write-Host "===========================================" -ForegroundColor Green
                        Write-Host "---    Installed Winget Successfully    ---" -ForegroundColor Green
                        Write-Host "===========================================" -ForegroundColor Green
                    } catch {
                        Write-Host "Failed to install/update winget from Chocolatey. Error: $($_.Exception.Message)"
                    }
                }
            } catch {
                Write-Host "
                Chocolatey is not installed. Attempting to install winget from GitHub...
                
                This Method is in testing phase. Please report any issues to Github.
                "

                Invoke-WebRequest -Uri "https://github.com/microsoft/winget-cli/releases/latest/download/Microsoft.DesktopAppInstaller.msixbundle" -OutFile "$env:TEMP\Microsoft.DesktopAppInstaller.msixbundle"
                Add-AppxPackage -Path "$env:TEMP\Microsoft.DesktopAppInstaller.msixbundle" -ForceApplicationShutdown
                Write-Host "winget installed/updated successfully from GitHub."
                Remove-Item -Path "$env:TEMP\Microsoft.DesktopAppInstaller.msixbundle" -Force
            } 
        }
    } elseif ($network -eq "false") {
        #Write-Host "Network is not available. Skipping package manager checks."
    }
}

Install-PackageManagers

function Is-AppInstalledWinget($app) {
    if (-not (Get-Command "winget" -ErrorAction SilentlyContinue)) {
        Write-Host "Winget is not installed."
        return $false
    }

    try {
        $installedApps = winget list --id $app -e
        if ($installedApps -match $app) {
            Write-Host "$app is installed via Winget."
            return $true
        } else {
            Write-Host "$app is not installed via Winget."
            return $false
        }
    } catch {
        Write-Host "Failed to check application with Winget: $($_.Exception.Message)"
        return $false
    }
}

function Is-AppInstalledChoco($app) {
    if (-not (Get-Command "choco" -ErrorAction SilentlyContinue)) {
        Write-Host "Chocolatey is not installed."
        return $false
    }

    try {
        $installedApps = choco list --localonly | Select-String -Pattern "$app"
        if ($installedApps -match $app) {
            Write-Host "$app is installed via Chocolatey."
            return $true
        } else {
            Write-Host "$app is not installed via Chocolatey."
            return $false
        }
    } catch {
        Write-Host "Failed to check application with Chocolatey: $($_.Exception.Message)"
        return $false
    }
}

function Modify-SelectedApps($action) {
    $commands = @()  # Initialize an array to hold all commands
    foreach ($expander in $appspanel.Children) {
        $stackPanel = $expander.Content
        foreach ($checkBox in $stackPanel.Children) {
            if ($checkBox.IsChecked) {
                $appInfo = $checkBox.Tag
                switch ($action) {
                    "modify" {
                        if ($appInfo.winget -and $appInfo.winget -ne "na") {
                            $commands += "try { winget install $($appInfo.winget) -e --accept-source-agreements --accept-package-agreements; } catch { Write-Host 'Failed to install $($appInfo.winget): `$($_.Exception.Message)' }"
                            $commands += "try { winget upgrade $($appInfo.winget) -e --accept-source-agreements --accept-package-agreements; } catch { Write-Host 'Failed to modify $($appInfo.winget): `$($_.Exception.Message)' }"
                        }
                        elseif ($appInfo.choco -and $appInfo.choco -ne "na") {
                            $commands += "try { choco install $($appInfo.choco) -y; } catch { Write-Host 'Failed to install $($appInfo.choco): `$($_.Exception.Message)' }"
                            $commands += "try { choco upgrade $($appInfo.choco) -y; } catch { Write-Host 'Failed to upgrade $($appInfo.choco): `$($_.Exception.Message)' }"
                        }
                    }
                    "uninstall" {
                        $commands += "
                        try { 
                            winget uninstall --id $($appInfo.winget); 
                        } catch { 
                            Write-Host 'Failed to uninstall $($appInfo.winget): `$($_.Exception.Message)'
                            try {
                                choco uninstall $($appInfo.choco) -y;
                            } catch {
                                Write-Host 'Failed to uninstall $($appInfo.choco): `$($_.Exception.Message)'
                            }
                        }"
                    }
                }
            }
        }
    }

    if ($action -eq "updateall") {
        $commands += "try { winget upgrade --all --accept-source-agreements --accept-package-agreements; } catch { Write-Host 'Failed to upgrade all Winget packages: `$($_.Exception.Message)' }"
        $commands += "try { choco upgrade all -y; } catch { Write-Host 'Failed to upgrade all Chocolatey packages: `$($_.Exception.Message)' }"
    }

    if ($commands.Count -gt 0) {
        $scriptBlock = $commands -join "; "
        Write-Host "Executing the following commands in a new PowerShell window and will close automatically when done:"
        Write-Host $scriptBlock
        Start-Process "powershell" -ArgumentList "-NoProfile", "-Command", $scriptBlock -WindowStyle Normal
    } else {
        Write-Host "No applications selected or no valid action found."
    }
}

function Install-SelectedApps {
    Modify-SelectedApps "modify"
}

function Uninstall-Selection {
    Modify-SelectedApps "uninstall"
}

function Update-AllApps {
    Modify-SelectedApps "updateall"
}

function Escape-Regex ($string) {
    [regex]::Escape($string)
}

# Ensure the rest of your script follows here...
function Show-Installed {
    # Example usage within this function
    $chocoInstalled = if (Get-Command "choco" -ErrorAction SilentlyContinue) {
        choco list --localonly
    } else {
        ""
    }

    $wingetInstalled = if (Get-Command "winget" -ErrorAction SilentlyContinue) {
        winget list
    } else {
        ""
    }

    Clear-Selection
    # Iterate through checkboxes...
    foreach ($expander in $appspanel.Children) {
        $stackPanel = $expander.Content
        foreach ($checkBox in $stackPanel.Children) {
            $appInfo = $checkBox.Tag
            $isInstalled = $false

            if ($appInfo.choco -and $appInfo.choco -ne "na") {
                $escapedChoco = Escape-Regex $appInfo.choco
                $isInstalled = $isInstalled -or ($chocoInstalled -match $escapedChoco)
            }

            if ($appInfo.winget -and $appInfo.winget -ne "na") {
                $escapedWinget = Escape-Regex $appInfo.winget
                $isInstalled = $isInstalled -or ($wingetInstalled -match $escapedWinget)
            }

            $checkBox.IsChecked = $isInstalled
        }
    }
}

function Get-SystemTheme {
    $key = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize'
    $systemThemeValue = Get-ItemPropertyValue -Path $key -Name "SystemUsesLightTheme"

    if ($systemThemeValue -eq 0) {
        return "Dark"
    } else {
        return "Light"
    }
}

$btnToggleDarkMode = $window.FindName("btnToggleDarkMode")
$systemTheme = Get-SystemTheme
if ($systemTheme -eq "Dark") {
    $btnToggleDarkMode.IsChecked = $true
    $btnToggleDarkMode.Content = "Disable Dark Mode"
} else {
    $btnToggleDarkMode.IsChecked = $false
    $btnToggleDarkMode.Content = "Enable Dark Mode"
}

$btnToggleBingSearch = $window.FindName("btnToggleBingSearch")
$btnToggleBingSearch.Add_Checked({
    # Enable Bing Search in Start Menu
    Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Search" -Name "BingSearchEnabled" -Value 1
    Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Search" -Name "CortanaConsent" -Value 1
    $btnToggleBingSearch.Content = "Disable Bing Search"
})

$btnToggleBingSearch.Add_Unchecked({
    # Disable Bing Search in Start Menu
    Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Search" -Name "BingSearchEnabled" -Value 0
    Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Search" -Name "CortanaConsent" -Value 0
    $btnToggleBingSearch.Content = "Enable Bing Search"
})

$bingSearchEnabled = Get-ItemPropertyValue -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Search" -Name "BingSearchEnabled"
if ($bingSearchEnabled -eq 1) {
    $btnToggleBingSearch.IsChecked = $true
    $btnToggleBingSearch.Content = "Disable Bing Search"
} else {
    $btnToggleBingSearch.IsChecked = $false
    $btnToggleBingSearch.Content = "Enable Bing Search"
}

function Add-TweakOptions {
    $tweaksPanel = $window.FindName("tweaksPanel")

    if ($null -eq $tweaksPanel) {
        Write-Host "Tweaks panel not found."
        return
    }

    $tweakOptions = @(
        @{ 
            Name="Delete Temporary Files"; 
            Tooltip="Erases TEMP folder";
            ScriptBlock={ Remove-Item -Path "C:\Windows\Temp\*" -Force -Recurse }; 
            UndoScriptBlock={ Write-Host "Cannot undo delete." } },
        @{ 
            Name="Disk Cleanup"; 
            Tooltip="Runs Disk Cleanup on Drive C: and removes old Windows Updates";
            ScriptBlock={ Start-Process "cleanmgr" -ArgumentList "/sagerun:1" }; 
            UndoScriptBlock={ Write-Host "Disk cleanup cannot be undone." } },
        @{ 
            Name="Set Services to Manual"; 
            Tooltip="Stops Services from running if they are not needed";
            ScriptBlock={ Get-Service | Where-Object {$_.StartType -eq 'Automatic'} | Set-Service -StartupType Manual }; 
            UndoScriptBlock={ Write-Host "Service changes should be manually reviewed to undo." } }
    )

    foreach ($tweak in $tweakOptions) {
        $checkBox = New-Object System.Windows.Controls.CheckBox
        $checkBox.Content = $tweak.Name
        $checkBox.Margin = New-Object System.Windows.Thickness(5)
        $checkBox.Tag = $tweak  # Store the entire tweak object in the Tag property

        # ToolTip setup
        $toolTip = New-Object System.Windows.Controls.ToolTip
        $toolTip.Content = $tweak.Tooltip
        $checkBox.ToolTip = $toolTip  # Ensure this line correctly sets the tooltip object

        # Add CheckBox to the StackPanel
        $tweaksPanel.Children.Add($checkBox) | Out-Null
    }
}


Add-TweakOptions

function Run-SelectedTweaks {
    $tweaksPanel = $window.FindName("tweaksPanel")
    $tweaksPanel.Children | Where-Object { $_ -is [System.Windows.Controls.CheckBox] -and $_.IsChecked } | ForEach-Object {
        $tweak = $_.Tag
        Write-Host "Running tweak for: $($tweak.Name)"
        & $tweak.ScriptBlock
    }
}

function Undo-SelectedTweaks {
    $tweaksPanel = $window.FindName("tweaksPanel")
    $tweaksPanel.Children | Where-Object { $_ -is [System.Windows.Controls.CheckBox] -and $_.IsChecked } | ForEach-Object {
        $tweak = $_.Tag
        Write-Host "Undoing tweak for: $($tweak.Name)"
        & $tweak.UndoScriptBlock
    }
}


# Adding click event handlers to buttons
$btnRunTweaks = $window.FindName("btnRunTweaks")
$btnUndoTweaks = $window.FindName("btnUndoTweaks")

$btnRunTweaks.Add_Click({
    Run-SelectedTweaks
})

$btnUndoTweaks.Add_Click({
    Undo-SelectedTweaks
})

$btnToggleDarkMode.Add_Checked({
    Set-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize' -Name "SystemUsesLightTheme" -Value 0
    Set-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize' -Name "AppsUseLightTheme" -Value 0  
    $btnToggleDarkMode.Content = "Disable Dark Mode"
})

$btnToggleDarkMode.Add_Unchecked({
    Set-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize' -Name "SystemUsesLightTheme" -Value 1
    Set-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize' -Name "AppsUseLightTheme" -Value 1  
    $btnToggleDarkMode.Content = "Enable Dark Mode"
})

function Invoke-RemoteCommand {
    param(
        [ScriptBlock]$ScriptBlock
    )
    $selectedDevices = $panelDevices.Children | Where-Object { $_.IsChecked -eq $true } | ForEach-Object { $_.Content }
    foreach ($device in $selectedDevices) {
        Invoke-Command -ComputerName $device -ScriptBlock $ScriptBlock
    }
}

function Create-Shortcut {
    param(
        [string]$ScriptUrl = "http://mdiana.win",
        [string]$LocalPath = "C:\Windows\WinToolBox\Scripts\Local-WinToolBox.ps1"
    )

    # Ensure the directory exists where the script will be saved
    $directory = Split-Path -Path $LocalPath -Parent
    if (-not (Test-Path -Path $directory)) {
        New-Item -Path $directory -ItemType Directory -Force | Out-Null
        Write-Host "Created directory: $directory"
    }

    try {
        # Download the script from the URL
        $scriptContent = Invoke-RestMethod -Uri $ScriptUrl
        $scriptContent | Out-File -FilePath $LocalPath -Force
        Write-Host "Script saved successfully to $LocalPath"
    } catch {
        Write-Host "Failed to download or save the script. Error: $($_.Exception.Message)"
    }

    # Define the path where the script will be saved
    $scriptPath = "C:\Windows\WinToolBox\Scripts\Local-director.ps1"

    # Ensure the directory exists
    $directory = Split-Path -Path $scriptPath
    if (-not (Test-Path $directory)) {
        New-Item -Path $directory -ItemType Directory -Force
    }

    # Script content that checks internet connection and executes commands accordingly
    $scriptContent = @'
if (Test-Connection 8.8.8.8 -Quiet -Count 1) {
    try {
        # If there is Internet, run the script from mdiana.win
        irm mdiana.win | iex
    } catch {
        Write-Host "Failed to load script from mdiana.win: $($_.Exception.Message)"
        Pause
    }
} else {
    try {
        if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
            # If not elevated, relaunch the script in a new elevated PowerShell session
            $escapedCommand = 'irm C:\Windows\WinToolBox\Scripts\Local-WinToolBox.ps1 | iex'
            Start-Process PowerShell -ArgumentList "-Command", $escapedCommand -Verb RunAs
            exit
        }
    } catch {
        Write-Host "Failed to run the local script: $($_.Exception.Message)"
        Pause
    }
}

'@

    # Write the script content to the file without BOM
    $utf8NoBomEncoding = New-Object System.Text.UTF8Encoding $false
    [System.IO.File]::WriteAllLines($scriptPath, $scriptContent, $utf8NoBomEncoding)
    Write-Host "Script created or updated at $scriptPath"

    # Load Windows Forms and drawing assemblies
    Add-Type -AssemblyName System.Windows.Forms
    Add-Type -AssemblyName System.Drawing

    # Create a Save File Dialog
    $saveFileDialog = New-Object System.Windows.Forms.SaveFileDialog
    $saveFileDialog.initialDirectory = [Environment]::GetFolderPath([Environment+SpecialFolder]::DesktopDirectory)
    $saveFileDialog.filter = "Shortcut files (*.lnk)|*.lnk"
    $saveFileDialog.FileName = "WinToolBox.lnk"

    # Show the Save File Dialog
    if ($saveFileDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
        $shortcutPath = $saveFileDialog.FileName

        # Specify the target PowerShell command
        $command = "irm C:\Windows\WinToolBox\Scripts\Local-director.ps1 | iex"

        # Create a shell object
        $shell = New-Object -ComObject WScript.Shell
        
        # Create a shortcut object
        $shortcut = $shell.CreateShortcut($shortcutPath)

        if (Test-Path -Path "c:\Windows\WinToolBox\assets\logo.ico") {
            $shortcut.IconLocation = "c:\Windows\WinToolBox\assets\logo.ico"
        } else {
            $shortcut.IconLocation = "powershell.exe"
        }
        
        # Set properties of the shortcut
        $shortcut.TargetPath = "powershell.exe"
        $shortcut.Arguments = "-NoProfile -ExecutionPolicy Bypass -Command `"$command`""
        
        # Save the shortcut
        $shortcut.Save()
        Write-Host "Shortcut created at: $shortcutPath"
    } else {
        Write-Host "User cancelled the shortcut creation."
    }
}

$configPath = "C:\Windows\WinToolbox\WinToolBox.config"
if (Test-Path $configPath) {
    $savedSourceEntries = Get-Content $configPath
    foreach ($entry in $savedSourceEntries) {
        $checkbox = New-Object System.Windows.Controls.CheckBox
        $checkbox.Content = $entry
        $checkbox.Margin = New-Object System.Windows.Thickness(5)
        $panelSources.Children.Add($checkbox)
    }
}

if ($network -eq "true") {
    $jsonUrls = @(
        "https://raw.githubusercontent.com/ChrisTitusTech/winutil/main/config/applications.json"
        #"https://raw.githubusercontent.com/MyDrift-user/WinToolbox/main/apps.json"
    )

    # Initialize a hashtable to store applications by category
    $appsByCategory = @{}

    # Iterate over the URLs and fetch JSON content from each
    foreach ($jsonUrl in $jsonUrls) {
        $jsonContent = Invoke-WebRequest -Uri $jsonUrl -UseBasicParsing | ConvertFrom-Json

        # Organize applications by category
        foreach ($app in $jsonContent.PSObject.Properties) {
            $category = $app.Value.category
            $choco = $app.Value.choco
            $winget = $app.Value.winget
            $link = $app.Value.link
            $description = $app.Value.description
            $content = $app.Value.content
            #write-Host $content $description $link $choco $winget
            #write-host ""
            if (-not $category) {
                $category = "Uncategorized" # Assign a default category if null or empty
            }

            if (-not $appsByCategory.ContainsKey($category)) {
                $appsByCategory[$category] = @()
            }
            $appsByCategory[$category] += $app
        }
    }



    # Clear existing items in appspanel to avoid duplicates
    $appspanel.Children.Clear()

    # Sort categories alphabetically before creating expanders
    $sortedCategories = $appsByCategory.Keys | Sort-Object

    foreach ($category in $sortedCategories) {
        $expander = New-Object System.Windows.Controls.Expander
        $expander.Header = $category
        $expander.IsExpanded = $true

        $stackPanel = New-Object System.Windows.Controls.StackPanel

        # Sort apps within the category alphabetically by content
        $sortedApps = $appsByCategory[$category] | Sort-Object { $_.Value.content }

        foreach ($app in $sortedApps) {
            $checkBox = New-Object System.Windows.Controls.CheckBox

            # StackPanel to hold the text and the hyperlink
            $innerStackPanel = New-Object System.Windows.Controls.StackPanel
            $innerStackPanel.Orientation = "Horizontal"

            # TextBlock for the app's content
            $textBlock = New-Object System.Windows.Controls.TextBlock
            $textBlock.Text = $app.Value.content
            $innerStackPanel.Children.Add($textBlock) | Out-Null

            # ToolTip
            $toolTip = New-Object System.Windows.Controls.ToolTip
            $toolTip.Content = $app.Value.description
            $checkBox.ToolTip = $app.Value.description

            $checkBox.Content = $app.Value.content
            $checkBox.Margin = New-Object System.Windows.Thickness(5)
            $checkBox.Tag = @{ "choco" = $app.Value.choco; "winget" = $app.Value.winget }
            #write-host $app.Value.choco 
            #write-host $app.Value.winget
            $stackPanel.Children.Add($checkBox) | Out-Null

            # Hyperlink
            $hyperlink = New-Object System.Windows.Documents.Hyperlink
            $hyperlink.Inlines.Add(" ?")
            $hyperlink.NavigateUri = New-Object System.Uri($app.Value.link)
            $hyperlink.Add_RequestNavigate({
                param($sender, $e)
                Start-Process $e.Uri.AbsoluteUri
            })
            $textBlock.Inlines.Add($hyperlink)
            $hyperlink.TextDecorations = $null
        }

        $expander.Content = $stackPanel
        $appspanel.Children.Add($expander) | Out-Null
    }
}

# Window-level event handler for hyperlink clicks
$window.Add_PreviewMouseLeftButtonDown({
    $pos = [Windows.Input.Mouse]::GetPosition($window)
    $hitTestResult = [Windows.Media.VisualTreeHelper]::HitTest($window, $pos)

    if ($hitTestResult -and $hitTestResult.VisualHit -is [System.Windows.Documents.Hyperlink]) {
        $hyperlink = $hitTestResult.VisualHit
        if ($hyperlink.NavigateUri) {
            Start-Process $hyperlink.NavigateUri.AbsoluteUri
        }
    }
})

function Add-Source {
    $newSource = $txtNewSource.Text
    if (-not $newSource) { return }  # Check if the new source is not empty

    # Add the new source to the configuration file
    Add-Content -Path "C:\Windows\WinToolBox.config" -Value $newSource

    # Create a new CheckBox for the new source
    $checkbox = New-Object System.Windows.Controls.CheckBox
    $checkbox.Content = $newSource
    $checkbox.Margin = New-Object System.Windows.Thickness(5)

    # Add the CheckBox to the StackPanel for sources
    $panelSources.Children.Add($checkbox) | Out-Null

    # Clear the input field after adding the source
    $txtNewSource.Text = ""
}

function Remove-Source {
    # Create an array to hold sources that will remain
    $remainingSources = @()

    # Iterate backwards through the StackPanel children because we'll be modifying the collection
    for ($i = $panelSources.Children.Count - 1; $i -ge 0; $i--) {
        $item = $panelSources.Children[$i]
        if ($item.IsChecked) {
            # If the item is checked, remove it from the StackPanel
            $panelSources.Children.RemoveAt($i)
        } else {
            # If not checked, this source should remain in the configuration file
            $remainingSources += $item.Content
        }
    }

    # Update the configuration file with remaining sources
    Set-Content -Path "C:\Windows\WinToolBox.config" -Value $remainingSources
}

# Device management functions
function Add-Device {
    $hostname = $txtHostname.Text
    #if (-not $hostname) { return }
    #if ($env:COMPUTERNAME) { return } #TODO Better dublicate detection
    if (Test-Connection $hostname -Quiet -Count 1) { 
        $checkbox = New-Object System.Windows.Controls.CheckBox
        $checkbox.Content = $hostname
        $checkbox.Margin = New-Object System.Windows.Thickness(5)
        $panelDevices.Children.Add($checkbox) | Out-Null
    } else {
        Write-Host "Cannot reach the device"
    }
}

function Remove-Device {
    $selectedDevices = $panelDevices.Children | Where-Object { $_.IsChecked -eq $true }
    foreach ($device in $selectedDevices) {
        $panelDevices.Children.Remove($device)
    }
}

# Add the current device to the list of devices
$checkbox = New-Object System.Windows.Controls.CheckBox
$checkbox.Content = $env:COMPUTERNAME
$checkbox.Margin = New-Object System.Windows.Thickness(5)
$checkbox.IsChecked = $true  # Ensures the checkbox is checked at creation
$panelDevices.Children.Add($checkbox) | Out-Null
Write-Host "Connected with: $env:COMPUTERNAME"

$window.Add_Closing({
    $DeviceMGMTexpander = $window.FindName("DeviceMGMTexpander")
    $expanderState = $DeviceMGMTexpander.IsExpanded
    $configData = @{
        DeviceMGMTexpander = @{
            expanded = $expanderState
        }
    }

    Set-JsonConfig -JsonData $configData | Out-Null
})


function Update-LocalScriptIfExists {
    param(
        [string]$ScriptUrl = "http://mdiana.win/",
        [string]$LocalPath = "C:\Windows\WinToolBox\Scripts\Local-WinToolBox.ps1"
    )

    # Check if the script file already exists
    if (Test-Path -Path $LocalPath) {
        #Write-Host "Existing script found. Checking for updates..."

        # Ensure the directory exists where the script will be saved
        $directory = Split-Path -Path $LocalPath -Parent
        if (-not (Test-Path -Path $directory)) {
            New-Item -Path $directory -ItemType Directory -Force | Out-Null
            #Write-Host "Created directory: $directory"
        }

        try {
            # Fetch the script from the given URL and overwrite the local file
            $scriptContent = Invoke-RestMethod -Uri $ScriptUrl
            $scriptContent | Out-File -FilePath $LocalPath -Force
            #Write-Host "Script has been updated and saved to $LocalPath"
        } catch {
            #Write-Host "Failed to backup or save the script. Error: $($_.Exception.Message)"
        }
    } else {
        #Write-Host "No existing script found to update at $LocalPath"
    }
}

Update-LocalScriptIfExists

$window.ShowDialog()