################################################################################################################
###                                                                                                          ###
### WARNING: This file is automatically generated DO NOT modify this file directly as it will be overwritten ###
###                                                                                                          ###
################################################################################################################

<#
.NOTES
    Author         : MyDrift @mydrift-user
    GitHub         : https://github.com/mydrift-user
    ?              : pnp powershell instead of Get-Credential?
    TODO           : create session without prequisits on remote machine
    TODO           : make locally accessable (elevated shell start fetch code from saved source instead of from the website the second time, ability to make local shortcuts)
    TODO           : if network available, show apps to install. else notify user and still let him make tweaks ...
    TODO           : delete logs older than 30 days | create config for that (checkbox in settings tab (rename sources to settings) rename sources as subtab)
    TODO           : package as .exe (github & website)
    TODO           : save an additional script and put it in task scheduler. after 30 days of not running the script it deleats the logs, the task and itself.
    TODO           : Run on system boot -> task scheduler checks for windows version change and then runs the selected/needed tweaks.
#>



# check if codes are running in an elevated session. if not, restart the script in an elevated session
if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
    # If not elevated, relaunch the script in a new elevated PowerShell session
    #TODO save script in directory, change escapedcommand to run that saved script instead of rerequest code.
    $escapedCommand = 'irm mdiana.win | iex'
    Start-Process PowerShell -ArgumentList "-Command", $escapedCommand -Verb RunAs
    exit
}


Write-Host "

MMMMMMMM               MMMMMMMM    DDDDDDDDDDDDDD        
M:::::::M             M:::::::M    D:::::::::::::DDD     
M::::::::M           M::::::::M    D::::::::::::::::DD   
M:::::::::M         M:::::::::M    DDD:::::DDDDD::::::D  
M::::::::::M       M::::::::::M       D:::::D   D::::::D 
M:::::::::::M     M:::::::::::M       D:::::D    D::::::D
M:::::::M::::M   M::::M:::::::M       D:::::D     D::::::D
M::::::M M::::M M::::M M::::::M       D:::::D     D::::::D
M::::::M  M::::M::::M  M::::::M       D:::::D     D::::::D
M::::::M   M:::::::M   M::::::M       D:::::D     D::::::D
M::::::M    M:::::M    M::::::M       D:::::D    D::::::D
M::::::M     MMMMM     M::::::M       D:::::D   D::::::D 
M::::::M               M::::::M    DDD:::::DDDDD::::::D  
M::::::M               M::::::M    D::::::::::::::::DD   
M::::::M               M::::::M    D:::::::::::::DDD     
MMMMMMMM               MMMMMMMM    DDDDDDDDDDDDDD        


========Mattia Diana========

=====Powershell Toolbox=====
=======Managing Device======


"

$dateTime = Get-Date -Format "dd-MM-yyyy_HH-mm-ss"
Start-Transcript -Path "C:\Windows\WinToolBox\Logs\WinToolBox_$dateTime.log" -Append
#Get-Content "C:\Windows\WinToolbox\Logs\manager_$dateTime.log"


# Function to install and import PsIni module
function Ensure-PsModule($moduleName) {
    $module = Get-Module -ListAvailable -Name $moduleName

    # Check if the module is not installed
    if (-not $module) {
        # Install Module from the PowerShell Gallery
        Write-Host ""
        Write-Host "Installing $moduleName module..."
        try {
            Install-Module -Name $moduleName -Repository PSGallery -Force -ErrorAction Stop
            Write-Host "$moduleName module installed successfully."
        } catch {
            Write-Host "Failed to install $moduleName module. Error: $($_.Exception.Message)"
            return
        }
    }

    try {
        Import-Module -Name $moduleName
        Write-Host "$moduleName module imported successfully."
    } catch {
        Write-Host "Failed to import $moduleName module. Error: $($_.Exception.Message)"
    }
}
# Call the function to ensure PsIni module is ready
Ensure-PsModule 'psini'
#Ensure-PsModule 'PoshTaskbarItem'

# Load WPF and XAML libraries
Add-Type -AssemblyName PresentationCore, WindowsBase, PresentationFramework, System.Drawing, WindowsFormsIntegration

# WPF GUI Design in XAML
[xml]$xaml = @"
<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="WinToolbox" Height="450" Width="800">
    <Window.Resources>
        <Style x:Key="ToggleSwitchStyle" TargetType="{x:Type ToggleButton}">
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="{x:Type ToggleButton}">
                        <Border x:Name="border" Width="50" Height="25" CornerRadius="12.5" BorderBrush="#00FFFFFF" BorderThickness="1"> <!-- or gray -->
                            <Grid x:Name="grid">
                                <!-- Toggle button (circle) is always white -->
                                <Ellipse Fill="White" Width="20" Height="20" Margin="1" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"/>
                            </Grid>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsChecked" Value="True">
                                <!-- Background changes to green when toggled on -->
                                <Setter TargetName="border" Property="Background" Value="#33a442" />
                                <Setter TargetName="grid" Property="HorizontalAlignment" Value="Right" />
                            </Trigger>
                            <Trigger Property="IsChecked" Value="False">
                                <!-- Background changes to red when toggled off -->
                                <Setter TargetName="border" Property="Background" Value="Red" />
                                <Setter TargetName="grid" Property="HorizontalAlignment" Value="Left" />
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </Window.Resources>

    <DockPanel LastChildFill="True">

        <Expander Name="DeviceMGMTexpander" ExpandDirection="Right" IsExpanded="False">
            <Grid Grid.Column="0">
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto" /> <!-- For static controls: TextBox and Buttons -->
                    <RowDefinition Height="*" /> <!-- For ScrollViewer, will take up remaining space -->
                </Grid.RowDefinitions>

                <StackPanel Grid.Row="0" Margin="10">
                    <TextBox Name="txtHostname" />
                    <Button Name="btnAdd" Content="Add" />
                    <Button Name="btnRemove" Content="Remove Selection" />
                </StackPanel>

                <!-- ScrollViewer in a separate row, taking up the remaining space -->
                <ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Hidden">
                    <StackPanel Name="panelDevices" />
                </ScrollViewer>
            </Grid>
        </Expander>
        
        <TabControl Grid.Column="1" Margin="10">
            <TabItem Header="Windows">
                <!-- Nested TabControl for the three new tabs -->
                <TabControl x:Name="subTabControl">
                    <TabItem Header="Applications" x:Name="tabApplications">
                        <Grid> <!-- Ein Grid als Container f端r die gesamte Struktur -->
                            <Grid.RowDefinitions>
                                <RowDefinition Height="Auto"/> <!-- Reihe f端r die Buttons -->
                                <RowDefinition Height="*"/> <!-- Reihe f端r den ScrollViewer -->
                            </Grid.RowDefinitions>

                            <!-- Buttons oben im Grid -->
                            <StackPanel Grid.Row="0" Orientation="Horizontal" HorizontalAlignment="Left" Margin="10">
                                <Button Name="btnInstallSelection" Content="Install/Upgrade Selection" Margin="5"/>
                                <Button Name="btnUpdateAll" Content="Update All" Margin="5"/>
                                <Button Name="btnUninstallSelection" Content="Uninstall Selection" Margin="5"/>
                                <Button Name="btnShowInstalled" Content="Show Installed" Margin="5"/>
                                <Button Name="btnClearSelection" Content="Clear Selection" Margin="5"/>
                            </StackPanel>

                            <!-- ScrollViewer f端r die Applikationsliste in der zweiten Reihe des Grids -->
                            <ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Auto">
                                <WrapPanel Name="appspanel" Orientation="Horizontal">
                                        <!-- Dynamically added CheckBoxes will be placed here -->
                                </WrapPanel>
                            </ScrollViewer>
                        </Grid>
                    </TabItem>

                    <TabItem Header="Tweaks">
                        <Grid>
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="*" />
                                <ColumnDefinition Width="*" />
                            </Grid.ColumnDefinitions>

                            <!-- First Column for checkboxes and buttons -->
                            <Grid Grid.Column="0">
                                <Grid.RowDefinitions>
                                    <RowDefinition Height="*" />
                                    <RowDefinition Height="Auto" />
                                </Grid.RowDefinitions>

                                <!-- Checkboxes StackPanel -->
                                <StackPanel Name="tweaksPanel" Margin="10">
                                    <!-- Checkboxes will be added here in the script -->
                                </StackPanel>

                                <!-- Buttons at the bottom -->
                                <StackPanel Grid.Row="1" Orientation="Horizontal" HorizontalAlignment="Center" Margin="10">
                                    <Button Name="btnRunTweaks" Content="Run Selected" Margin="5" Width="100" />
                                    <Button Name="btnUndoTweaks" Content="Undo Selected" Margin="5" Width="100" />
                                </StackPanel>
                            </Grid>

                            <!-- Second Column for toggle switch and other controls -->
                            <StackPanel Grid.Column="1" Margin="10">
                                <ToggleButton Name="btnToggleDarkMode" Style="{StaticResource ToggleSwitchStyle}" Margin="10" IsChecked="False" HorizontalAlignment="Left"/>
                                <TextBlock Name="txtToggleTheme" VerticalAlignment="Center" Text="Dark Mode" HorizontalAlignment="Left"/>
                                
                                <ToggleButton Name="btnToggleBingSearch" Style="{StaticResource ToggleSwitchStyle}" Margin="10" IsChecked="False" HorizontalAlignment="Left"/>
                                <TextBlock Name="txtToggleBingSearchStatus" VerticalAlignment="Center" Text="Bing Search in Start Menu" HorizontalAlignment="Left"/>


                                <Button Name="btnCreateShortcut" Content="Create Shortcut" Margin="5" HorizontalAlignment="Left"/>
                            </StackPanel>

                        </Grid>
                    </TabItem>


                </TabControl>
            </TabItem>
            <TabItem Header="Sources">
                <StackPanel Margin="10">
                    <DockPanel LastChildFill="False">
                        <TextBox Name="txtNewSource" DockPanel.Dock="Left" Width="200" Margin="0,0,5,10"/>
                        <ComboBox Name="cmbSourceType" Width="120" Margin="0,0,5,10">
                            <ComboBoxItem Content="Application"/>
                            <ComboBoxItem Content="Tweak"/>
                        </ComboBox>
                        <Button Name="btnAddSource" Content="Add" Width="75" Margin="5,0,0,10"/>
                    </DockPanel>
                    <TextBlock Margin="0,20,0,0" FontWeight="Bold">Current Sources:</TextBlock>
                    <ScrollViewer VerticalScrollBarVisibility="Visible">
                        <StackPanel Name="panelSources" />
                    </ScrollViewer>
                    <Button Name="btnDeleteSource" Content="Delete Source" Margin="10"/>
                </StackPanel>
            </TabItem>
        </TabControl>
    </DockPanel>
</Window>
"@

# Parse the XAML
$reader = New-Object System.Xml.XmlNodeReader $xaml
$window = [Windows.Markup.XamlReader]::Load($reader)

# URL to the ICO file
$iconUrl = "https://raw.githubusercontent.com/MyDrift-user/WinToolbox/main/logo.ico"
$iconPath = "C:\Windows\WinToolbox\assets\logo.ico"


# Ensure the directory exists
$directoryPath = [System.IO.Path]::GetDirectoryName($iconPath)
if (-not (Test-Path -Path $directoryPath)) {
    Write-Host "Creating directory: $directoryPath"
    New-Item -Path $directoryPath -ItemType Directory -Force
}

# Download the ICO file
try {
    Invoke-WebRequest -Uri $iconUrl -OutFile $iconPath

    # Create an ImageSource from the ICO file
    $iconUri = New-Object System.Uri($iconPath)
    $iconBitmap = New-Object System.Windows.Media.Imaging.BitmapImage($iconUri)

    # Set the Window Icon
    $window.Icon = $iconBitmap

} catch {
    Write-Host "Failed to download & load the ICO file. Error: $($_.Exception.Message)"
}

# Access controls from the parsed XAML
$txtHostname = $window.FindName("txtHostname")
$btnAdd = $window.FindName("btnAdd")
$btnRemove = $window.FindName("btnRemove")
$panelDevices = $window.FindName("panelDevices")
$btnRun = $window.FindName("btnRun")

$subTabControl = $window.FindName("subTabControl")

$txtNewSource = $window.FindName("txtNewSource")
$cmbSourceType = $window.FindName("cmbSourceType")
$btnAddSource = $window.FindName("btnAddSource")
$lstSources = $window.FindName("lstSources")
$panelSources = $window.FindName("panelSources")
$btnDeleteSource = $window.FindName("btnDeleteSource")
$btnAddSource.Add_Click({ Add-Source })
$btnDeleteSource.Add_Click({ Remove-Source })
$btnAdd.Add_Click({ Add-Device })
$btnRemove.Add_Click({ Remove-Device })


$btnInstallSelection = $window.FindName("btnInstallSelection")
$btnInstallSelection.Add_Click({ Install-SelectedApps })
$btnUninstallSelection = $window.FindName("btnUninstallSelection")
$btnUpdateAll = $window.FindName("btnUpdateAll")
$btnUpdateAll.Add_Click({ Update-AllApps })
$btnShowInstalled = $window.FindName("btnShowInstalled")
$btnUninstallSelection.Add_Click({ Uninstall-Selection })
$btnShowInstalled.Add_Click({ Show-Installed })

# Shortcut Creation
$btnCreateShortcut = $window.FindName("btnCreateShortcut")
$btnCreateShortcut.Add_Click({ Create-Shortcut })



$iniPath = "C:\Windows\WinToolBox\config.ini"
if (Test-Path $iniPath) {
    $iniContent = Get-IniContent -FilePath $iniPath
    $DeviceMGMTexpander = $window.FindName("DeviceMGMTexpander")
    if ($iniContent.DeviceMGMTexpander -and $iniContent.DeviceMGMTexpander.expanded -eq "True") {
        $DeviceMGMTexpander.IsExpanded = $true
    } else {
        $DeviceMGMTexpander.IsExpanded = $false
    }
    #Write-Host "Loaded expander state from $iniPath"
}


# Check for Internet connection before showing the window
$tabApplications = $window.FindName("tabApplications")  # Get the Applications tab reference

if (-not (Test-Connection 8.8.8.8 -Quiet -Count 1)) {
    $tabApplications.Visibility = [System.Windows.Visibility]::Collapsed
    $subTabControl.SelectedIndex = 1
    Write-Host "No Internet Connection: Hiding Applications Tab"
} else {
    $tabApplications.Visibility = [System.Windows.Visibility]::Visible
    $subTabControl.SelectedIndex = 0
    #Write-Host "Internet Connection Detected: Displaying Applications Tab"
}


function Install-PackageManagers {
    # Check if Chocolatey is installed
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        $currentVersion = choco --version | Out-String
        #Write-Host "Current Chocolatey version: $currentVersion"

        try {
            #Write-Host "Checking for updates for Chocolatey..."
            $output = choco upgrade chocolatey -y | Out-String  # Capture the full output as a string
            if ($output -like "*is the latest version available based on your source(s)*") {
                Write-Host "Chocolatey is installed. Version: $currentVersion"
            } elseif ($output -like "*Chocolatey upgraded 0/1 packages*") {
                Write-Host "No updates were needed; Chocolatey is already at the latest version. Version: $currentVersion"
            } elseif ($output -like "*Chocolatey upgraded 1/1 packages*" -or $output -like "*upgraded*") {
                $newVersion = choco --version | Out-String
                Write-Host "Chocolatey has been updated to the latest version: $newVersion"
            } else {
                Write-Host "Chocolatey update status is unclear. Check the output above for more details."
            }
        } catch {
            Write-Host "An error occurred while trying to update Chocolatey: $($_.Exception.Message)"
        }
    } else {
        Write-Host "Chocolatey is not installed. Installing now."
        try {
            # Installing Chocolatey
            Set-ExecutionPolicy Bypass -Scope Process -Force
            [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
            iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
            $installedVersion = choco --version | Out-String
            Write-Host "Chocolatey installed successfully. Version: $installedVersion"
        } catch {
            Write-Host "Failed to install Chocolatey: $($_.Exception.Message)"
        }
    }

    # Check and install/update winget
    try {
        $wingetInstalled = winget --version
        if ($wingetInstalled) {
            Write-Host "winget is installed. Version: $wingetInstalled"
        } else {
            throw "winget not installed"
        }
    } catch {
        Write-Host "Attempting to install/update winget from GitHub..."
        try {
            Invoke-WebRequest -Uri "https://github.com/microsoft/winget-cli/releases/latest/download/Microsoft.DesktopAppInstaller.msixbundle" -OutFile "$env:TEMP\Microsoft.DesktopAppInstaller.msixbundle"
            Add-AppxPackage -Path "$env:TEMP\Microsoft.DesktopAppInstaller.msixbundle" -ForceApplicationShutdown
            Write-Host "winget installed/updated successfully from GitHub."
        } catch {
            Write-Host "Failed to install/update winget from GitHub. Error: $($_.Exception.Message)"
            if (Get-Command choco -ErrorAction SilentlyContinue) {
                try {
                    choco install winget -y
                    Write-Host "winget installed/updated successfully from Chocolatey."
                } catch {
                    Write-Host "Failed to install/update winget from Chocolatey. Error: $($_.Exception.Message)"
                }
            }
        }
    }
}

Install-PackageManagers

function Modify-SelectedApps($action) {
    foreach ($expander in $appspanel.Children) {
        $stackPanel = $expander.Content
        foreach ($checkBox in $stackPanel.Children) {
            if ($checkBox.IsChecked) {
                $appInfo = $checkBox.Tag  # Assuming you have stored app info in the Tag property during checkbox creation
                try {
                    switch ($action) {
                        "modify" {
                            if ($appInfo.winget) {
                                $installedPackage = winget list --id $appInfo.winget -e | Where-Object { $_ -match $appInfo.winget }
                                if ($installedPackage) {
                                    $command = "winget upgrade $($appInfo.winget) -e --accept-source-agreements --accept-package-agreements"
                                    Write-Host "Upgrading $($checkBox.Content) using winget in a new PowerShell window"
                                } else {
                                    $command = "winget install $($appInfo.winget) -e --accept-source-agreements --accept-package-agreements"
                                    Write-Host "Installing $($checkBox.Content) using winget in a new PowerShell window"
                                }
                                Start-Process "powershell" -ArgumentList "-NoExit", "-Command", $command -WindowStyle Normal
                            } elseif ($appInfo.choco -and $appInfo.choco -ne "na") {
                                $installedPackage = choco list --localonly | Where-Object { $_ -like "*$($appInfo.choco)*" }
                                if ($installedPackage) {
                                    $command = "choco upgrade $($appInfo.choco) -y"
                                    Write-Host "Upgrading $($checkBox.Content) using Chocolatey in a new PowerShell window"
                                } else {
                                    $command = "choco install $($appInfo.choco) -y"
                                    Write-Host "Installing $($checkBox.Content) using Chocolatey in a new PowerShell window"
                                }
                                Start-Process "powershell" -ArgumentList "-NoExit", "-Command", $command -WindowStyle Normal
                            } else {
                                Write-Host "No method found for $($checkBox.Content)"
                            }
                        }
                        "uninstall" {
                            if ($appInfo.winget) {
                                $command = "winget uninstall --id $($appInfo.winget) --accept-source-agreements --accept-package-agreements"
                                Write-Host "Uninstalling $($checkBox.Content) using winget in a new PowerShell window"
                            } elseif ($appInfo.choco -and $appInfo.choco -ne "na") {
                                $command = "choco uninstall $($appInfo.choco) -y"
                                Write-Host "Uninstalling $($checkBox.Content) using Chocolatey in a new PowerShell window"
                            } else {
                                Write-Host "No uninstall method found for $($checkBox.Content)"
                            }
                            Start-Process "powershell" -ArgumentList "-NoExit", "-Command", $command -WindowStyle Normal
                        }
                        default {
                            Write-Host "Unsupported action: $action"
                        }
                    }
                } catch {
                    Write-Host "Failed to $action $($checkBox.Content). Error: $($_.Exception.Message)"
                }
            }
        }
    }
}





function Install-SelectedApps {
    Modify-SelectedApps "modify"
}

function Uninstall-Selection {
    Modify-SelectedApps "uninstall"
}

function Update-AllApps {
    foreach ($expander in $appspanel.Children) {
        $stackPanel = $expander.Content
        foreach ($checkBox in $stackPanel.Children) {

                $appInfo = $checkBox.Tag  # Assuming you have stored app info in the Tag property during checkbox creation
                try {
                    if ($appInfo.winget) { 
                        winget upgrade --all --accept-source-agreements --accept-package-agreements --scope=machine --silent
                    } elseif ($appInfo.choco -and $appInfo.choco -ne "na") {
                        $command = "choco upgrade $($appInfo.choco) -y"
                        Write-Host "Using Chocolatey to upgrade $($checkBox.Content)"
                        Invoke-Expression $command
                    } else {
                        Write-Host "No method found for $($checkBox.Content)"
                    }
                } catch {
                    Write-Host "Failed to upgrade $($checkBox.Content). Error: $($_.Exception.Message)"
                }

        }
    }
}


function Show-Installed {
    # Get list of installed applications from the registry
    $installedApps = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*, HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* |
                     Where-Object { $_.DisplayName -ne $null } |
                     Select-Object -ExpandProperty DisplayName

    # Iterate through all checkboxes in the app panel
    foreach ($expander in $appspanel.Children) {
        $stackPanel = $expander.Content
        foreach ($checkBox in $stackPanel.Children) {
            if ($installedApps -contains $checkBox.Content) {
                $checkBox.IsChecked = $true
                #Write-Host "$($checkBox.Content) is installed."
            } else {
                $checkBox.IsChecked = $false
            }
        }
    }
}

# Handler for clearing all application checkboxes
$btnClearSelection = $window.FindName("btnClearSelection")
$btnClearSelection.Add_Click({
    # Iterate through all checkboxes in the applications panel
    foreach ($expander in $appspanel.Children) {
        $stackPanel = $expander.Content
        foreach ($checkBox in $stackPanel.Children) {
            $checkBox.IsChecked = $false
        }
    }
})



function Get-SystemTheme {
    $key = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize'
    $systemThemeValue = Get-ItemPropertyValue -Path $key -Name "SystemUsesLightTheme"

    if ($systemThemeValue -eq 0) {
        return "Dark"
    } else {
        return "Light"
    }
}

$btnToggleDarkMode = $window.FindName("btnToggleDarkMode")
$systemTheme = Get-SystemTheme
if ($systemTheme -eq "Dark") {
    $btnToggleDarkMode.IsChecked = $true
    $btnToggleDarkMode.Content = "Disable Dark Mode"
} else {
    $btnToggleDarkMode.IsChecked = $false
    $btnToggleDarkMode.Content = "Enable Dark Mode"
}

$btnToggleBingSearch = $window.FindName("btnToggleBingSearch")
$btnToggleBingSearch.Add_Checked({
    # Enable Bing Search in Start Menu
    Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Search" -Name "BingSearchEnabled" -Value 1
    Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Search" -Name "CortanaConsent" -Value 1
    $btnToggleBingSearch.Content = "Disable Bing Search"
})

$btnToggleBingSearch.Add_Unchecked({
    # Disable Bing Search in Start Menu
    Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Search" -Name "BingSearchEnabled" -Value 0
    Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Search" -Name "CortanaConsent" -Value 0
    $btnToggleBingSearch.Content = "Enable Bing Search"
})

$bingSearchEnabled = Get-ItemPropertyValue -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Search" -Name "BingSearchEnabled"
if ($bingSearchEnabled -eq 1) {
    $btnToggleBingSearch.IsChecked = $true
    $btnToggleBingSearch.Content = "Disable Bing Search"
} else {
    $btnToggleBingSearch.IsChecked = $false
    $btnToggleBingSearch.Content = "Enable Bing Search"
}


function Add-TweakOptions {
    $tweaksPanel = $window.FindName("tweaksPanel")

    if ($null -eq $tweaksPanel) {
        Write-Host "Tweaks panel not found."
        return
    }

    $tweakOptions = @(
        @{ Name="Enable Feature X"; Description="Enables the experimental Feature X."; Tooltip="Be cautious, this is experimental."},
        @{ Name="Enable Logging"; Description="Starts detailed logging of the application."; Tooltip="This may impact performance."},
        @{ Name="Set Services to Manual"; Description="Services -> Manual"; Tooltip="Stops Services from running if they are not needed."}
    )

    foreach ($tweak in $tweakOptions) {
        $checkBox = New-Object System.Windows.Controls.CheckBox
        $checkBox.Content = $tweak.Name
        $checkBox.Margin = New-Object System.Windows.Thickness(5)

        # ToolTip setup
        $toolTip = New-Object System.Windows.Controls.ToolTip
        $toolTip.Content = $tweak.Tooltip
        $checkBox.ToolTip = $toolTip

        # Add CheckBox to the StackPanel
        $tweaksPanel.Children.Add($checkBox) | Out-Null
    }
}

Add-TweakOptions


# Function to handle running selected tweaks
function Run-SelectedTweaks {
    # Example of checking which checkboxes are checked and acting on them
    $tweaksPanel.Children | Where-Object { $_ -is [System.Windows.Controls.CheckBox] -and $_.IsChecked } | ForEach-Object {
        Write-Host "Running tweak for: $($_.Content)"
        # Insert logic to apply the tweak
    }
}

# Function to handle undoing selected tweaks
function Undo-SelectedTweaks {
    # Example of checking which checkboxes are checked and acting on them
    $tweaksPanel.Children | Where-Object { $_ -is [System.Windows.Controls.CheckBox] -and $_.IsChecked } | ForEach-Object {
        Write-Host "Undoing tweak for: $($_.Content)"
        # Insert logic to revert the tweak
    }
}

# Adding click event handlers to buttons
$btnRunTweaks = $window.FindName("btnRunTweaks")
$btnUndoTweaks = $window.FindName("btnUndoTweaks")

$btnRunTweaks.Add_Click({
    Run-SelectedTweaks
})

$btnUndoTweaks.Add_Click({
    Undo-SelectedTweaks
})


$btnToggleDarkMode.Add_Checked({
    Set-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize' -Name "SystemUsesLightTheme" -Value 0
    Set-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize' -Name "AppsUseLightTheme" -Value 0  
    $btnToggleDarkMode.Content = "Disable Dark Mode"
})

$btnToggleDarkMode.Add_Unchecked({
    Set-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize' -Name "SystemUsesLightTheme" -Value 1
    Set-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize' -Name "AppsUseLightTheme" -Value 1  
    $btnToggleDarkMode.Content = "Enable Dark Mode"
})



function Invoke-RemoteCommand {
    param(
        [ScriptBlock]$ScriptBlock
    )
    $selectedDevices = $panelDevices.Children | Where-Object { $_.IsChecked -eq $true } | ForEach-Object { $_.Content }
    foreach ($device in $selectedDevices) {
        Invoke-Command -ComputerName $device -ScriptBlock $ScriptBlock
    }
}


function Create-Shortcut {
    # Load Windows Forms and drawing assemblies
    Add-Type -AssemblyName System.Windows.Forms
    Add-Type -AssemblyName System.Drawing

    # Create a Save File Dialog
    $saveFileDialog = New-Object System.Windows.Forms.SaveFileDialog
    $saveFileDialog.initialDirectory = [Environment]::GetFolderPath([Environment+SpecialFolder]::DesktopDirectory)
    $saveFileDialog.filter = "Shortcut files (*.lnk)|*.lnk"
    $saveFileDialog.FileName = "WinToolBox.lnk"

    # Show the Save File Dialog
    if ($saveFileDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
        $shortcutPath = $saveFileDialog.FileName

        # Specify the target PowerShell command
        $command = "powershell.exe -NoProfile -ExecutionPolicy Bypass -Command 'irm mdiana.dev/win | iex'"

        # Create a shell object
        $shell = New-Object -ComObject WScript.Shell
        
        # Create a shortcut object
        $shortcut = $shell.CreateShortcut($shortcutPath)

        if (Test-Path -Path "c:\Windows\WinToolBox\assets\logo.ico") {
            $shortcut.IconLocation = "c:\Windows\WinToolBox\assets\logo.ico"
        } else {
            $shortcut.IconLocation = "powershell.exe"
        }
        
        # Set properties of the shortcut
        $shortcut.TargetPath = "powershell.exe"
        $shortcut.Arguments = "-NoProfile -ExecutionPolicy Bypass -Command `"$command`""
        
        # Save the shortcut
        $shortcut.Save()
        Write-Host "Shortcut created at: $shortcutPath"
    } else {
        Write-Host "User cancelled the shortcut creation."
    }
}


$jsonUrls = @(
    "https://raw.githubusercontent.com/ChrisTitusTech/winutil/main/config/applications.json"
    #"https://raw.githubusercontent.com/MyDrift-user/WinToolbox/main/apps.json"
)

$configPath = "C:\Windows\WinToolbox\WinToolBox.config"
if (Test-Path $configPath) {
    $savedSourceEntries = Get-Content $configPath
    foreach ($entry in $savedSourceEntries) {
        $checkbox = New-Object System.Windows.Controls.CheckBox
        $checkbox.Content = $entry
        $checkbox.Margin = New-Object System.Windows.Thickness(5)
        $panelSources.Children.Add($checkbox)
    }
}

# Initialize a hashtable to store applications by category
$appsByCategory = @{}

# Iterate over the URLs and fetch JSON content from each
foreach ($jsonUrl in $jsonUrls) {
    $jsonContent = Invoke-WebRequest -Uri $jsonUrl -UseBasicParsing | ConvertFrom-Json

    # Organize applications by category
    foreach ($app in $jsonContent.PSObject.Properties) {
        $category = $app.Value.category
        $choco = $app.Value.choco
        $winget = $app.Value.winget
        $link = $app.Value.link
        $description = $app.Value.description
        $content = $app.Value.content
        #write-Host $content $description $link $choco $winget
        #write-host ""
        if (-not $category) {
            $category = "Uncategorized" # Assign a default category if null or empty
        }

        if (-not $appsByCategory.ContainsKey($category)) {
            $appsByCategory[$category] = @()
        }
        $appsByCategory[$category] += $app
    }
}

# Correct XML manipulation
$appspanel = $window.FindName("appspanel")


# Clear existing items in appspanel to avoid duplicates
$appspanel.Children.Clear()

# Sort categories alphabetically before creating expanders
$sortedCategories = $appsByCategory.Keys | Sort-Object

foreach ($category in $sortedCategories) {
    $expander = New-Object System.Windows.Controls.Expander
    $expander.Header = $category
    $expander.IsExpanded = $true

    $stackPanel = New-Object System.Windows.Controls.StackPanel

    # Sort apps within the category alphabetically by content
    $sortedApps = $appsByCategory[$category] | Sort-Object { $_.Value.content }

    foreach ($app in $sortedApps) {
        $checkBox = New-Object System.Windows.Controls.CheckBox

        # StackPanel to hold the text and the hyperlink
        $innerStackPanel = New-Object System.Windows.Controls.StackPanel
        $innerStackPanel.Orientation = "Horizontal"

        # TextBlock for the app's content
        $textBlock = New-Object System.Windows.Controls.TextBlock
        $textBlock.Text = $app.Value.content
        $innerStackPanel.Children.Add($textBlock) | Out-Null

        # ToolTip
        $toolTip = New-Object System.Windows.Controls.ToolTip
        $toolTip.Content = $app.Value.description
        $checkBox.ToolTip = $app.Value.description

        $checkBox.Content = $app.Value.content
        $checkBox.Margin = New-Object System.Windows.Thickness(5)
        $checkBox.Tag = @{ "choco" = $app.Value.choco; "winget" = $app.Value.winget }
        #write-host $app.Value.choco 
        #write-host $app.Value.winget
        $stackPanel.Children.Add($checkBox) | Out-Null

        # Hyperlink
        $hyperlink = New-Object System.Windows.Documents.Hyperlink
        $hyperlink.Inlines.Add(" ?")
        $hyperlink.NavigateUri = New-Object System.Uri($app.Value.link)
        $hyperlink.Add_RequestNavigate({
            param($sender, $e)
            Start-Process $e.Uri.AbsoluteUri
        })
        $textBlock.Inlines.Add($hyperlink)
        $hyperlink.TextDecorations = $null
    }

    $expander.Content = $stackPanel
    $appspanel.Children.Add($expander) | Out-Null
}


# Window-level event handler for hyperlink clicks
$window.Add_PreviewMouseLeftButtonDown({
    $pos = [Windows.Input.Mouse]::GetPosition($window)
    $hitTestResult = [Windows.Media.VisualTreeHelper]::HitTest($window, $pos)

    if ($hitTestResult -and $hitTestResult.VisualHit -is [System.Windows.Documents.Hyperlink]) {
        $hyperlink = $hitTestResult.VisualHit
        if ($hyperlink.NavigateUri) {
            Start-Process $hyperlink.NavigateUri.AbsoluteUri
        }
    }
})


function Add-Source {
    $newSource = $txtNewSource.Text
    if (-not $newSource) { return }  # Check if the new source is not empty

    # Add the new source to the configuration file
    Add-Content -Path "C:\Windows\WinToolBox.config" -Value $newSource

    # Create a new CheckBox for the new source
    $checkbox = New-Object System.Windows.Controls.CheckBox
    $checkbox.Content = $newSource
    $checkbox.Margin = New-Object System.Windows.Thickness(5)

    # Add the CheckBox to the StackPanel for sources
    $panelSources.Children.Add($checkbox) | Out-Null

    # Clear the input field after adding the source
    $txtNewSource.Text = ""
}


function Remove-Source {
    # Create an array to hold sources that will remain
    $remainingSources = @()

    # Iterate backwards through the StackPanel children because we'll be modifying the collection
    for ($i = $panelSources.Children.Count - 1; $i -ge 0; $i--) {
        $item = $panelSources.Children[$i]
        if ($item.IsChecked) {
            # If the item is checked, remove it from the StackPanel
            $panelSources.Children.RemoveAt($i)
        } else {
            # If not checked, this source should remain in the configuration file
            $remainingSources += $item.Content
        }
    }

    # Update the configuration file with remaining sources
    Set-Content -Path "C:\Windows\WinToolBox.config" -Value $remainingSources
}

# Device management functions
function Add-Device {
    $hostname = $txtHostname.Text
    #if (-not $hostname) { return }
    #if ($env:COMPUTERNAME) { return } #TODO Better dublicate detection
    if (Test-Connection $hostname -Quiet -Count 1) { 
        $checkbox = New-Object System.Windows.Controls.CheckBox
        $checkbox.Content = $hostname
        $checkbox.Margin = New-Object System.Windows.Thickness(5)
        $panelDevices.Children.Add($checkbox) | Out-Null
    } else {
        Write-Host "Cannot reach the device"
    }
}

function Remove-Device {
    $selectedDevices = $panelDevices.Children | Where-Object { $_.IsChecked -eq $true }
    foreach ($device in $selectedDevices) {
        $panelDevices.Children.Remove($device)
    }
}


# Add the current device to the list of devices
$checkbox = New-Object System.Windows.Controls.CheckBox
$checkbox.Content = $env:COMPUTERNAME
$checkbox.Margin = New-Object System.Windows.Thickness(5)
$checkbox.IsChecked = $true  # Ensures the checkbox is checked at creation
$panelDevices.Children.Add($checkbox) | Out-Null
Write-Host "Connected with: $env:COMPUTERNAME"


$window.Add_Closing({
    $iniPath = "C:\Windows\WinToolBox\config.ini"
    $DeviceMGMTexpander = $window.FindName("DeviceMGMTexpander")
    $expanderState = $DeviceMGMTexpander.IsExpanded
    $iniContent = @{"DeviceMGMTexpander" = @{"expanded" = $expanderState}}
    $iniContent | Out-IniFile -FilePath $iniPath -Force
    #Write-Host "Saved expander state to $iniPath"
})

$window.ShowDialog()